import pandas as pd
from collections import Counter
from urllib.parse import urlparse, urlunparse
import logging

# Configure logging
logger = logging.getLogger(__name__)

def _get_parent_url(url_str: str) -> str | None:
    """
    Generates the parent URL by removing the last segment of the path,
    preserving the trailing slash if appropriate.

    Args:
        url_str: The input URL string.

    Returns:
        The parent URL string, or None if parsing fails or it's already a root/domain URL.
    """
    try:
        p = urlparse(url_str)
        path = p.path

        # Normalize path: remove trailing slash for manipulation, remember if it was there
        #original_had_slash = path.endswith('/') # We might not need this check explicitly
        norm_path = path.rstrip('/')

        # If normalized path is empty or just the root, it has no parent directory
        if not norm_path or norm_path == '/':
            return None

        # Find the last slash
        last_slash_index = norm_path.rfind('/')

        # If no slash found, or only the root slash, parent is the root directory
        if last_slash_index <= 0:
            parent_path = '/'
        else:
            # Parent path is up to the last slash
            parent_path = norm_path[:last_slash_index]
            # If the result is empty (e.g., path was /something), parent is root
            if not parent_path:
                 parent_path = '/'

        # Add trailing slash to parent path unless it IS the root path
        if parent_path != '/':
             parent_path += '/'

        # Reconstruct the URL with the new parent path
        # Ensure scheme and netloc are preserved
        parent_parsed = p._replace(path=parent_path, params="", query="", fragment="")
        return urlunparse(parent_parsed)

    except Exception as e:
        logger.error(f"Error generating parent URL for {url_str}: {e}")
        return None

def _get_top_suggestions(match_data: dict, top_n: int = 5) -> list[str]:
    """
    Extracts the most frequent live URL suggestions from the match data.

    Args:
        match_data: A dictionary representing a single 404 URL and its matches
                    from various algorithms (e.g., {'url_404': '...',
                    'matches': [('Algo1', 'live1', score1), ('Algo2', 'live1', score2), ...]}).
        top_n: The number of top suggestions to return.

    Returns:
        A list of the top N most frequently suggested live URLs.
    """
    suggestions = []
    # Check if the 'matches' key exists and is a list
    if 'matches' in match_data and isinstance(match_data['matches'], list):
        # Iterate through the list of tuples (algo_name, match_url, score)
        for _, match_url, _ in match_data['matches']:
            # Check if the match_url is not None or empty
            if match_url:
                # Add the suggested live URL to the list
                suggestions.append(match_url)

    # Count the frequency of each suggestion
    suggestion_counts = Counter(suggestions)
    # Get the top N most common suggestions
    top_suggestions = [url for url, count in suggestion_counts.most_common(top_n)]
    return top_suggestions

def start_active_learning_session(matches: list[dict], df_404: pd.DataFrame, df_live: pd.DataFrame) -> list[tuple[str, str]]:
    """
    Initiates an optional active learning loop for the user to verify matches.

    Args:
        matches: The list of match dictionaries generated by MatchingAlgorithms.
                 Each dict contains a '404_url' and results from various algos.
        df_404: DataFrame containing the original 404 URLs.
        df_live: DataFrame containing the live URLs.

    Returns:
        A list of tuples, where each tuple contains a (404_url, verified_live_url) pair
        confirmed by the user. Returns an empty list if the user declines or no
        matches are verified.
    """
    print("\n--- Active Learning Session ---")
    # Ask the user if they want to participate
    participate = input("Do you want to improve the ML system by verifying some URL matches? (yes/no): ").lower()

    if participate != 'yes':
        print("Skipping active learning.")
        return [] # Return an empty list if the user declines

    # Create a set of live URLs for faster lookups
    live_url_set = set(df_live['URL'])

    verified_pairs = [] # List to store user-verified (404_url, live_url) tuples
    # Revert the key back to 'url_404' to match the input structure
    matches_to_review = [m for m in matches if 'url_404' in m] # Filter out potential malformed entries

    if not matches_to_review:
        print("No matches available to review.")
        return []

    print(f"\nStarting review process. You can type 'quit' at any time to stop.")
    print("-" * 30)

    # Iterate through each 404 URL and its potential matches
    for i, match_info in enumerate(matches_to_review):
        # Revert the key used to get the 404 URL back to 'url_404'
        url_404 = match_info.get('url_404')
        if not url_404:
            # Use the correct key in the warning message as well
            logger.warning(f"Skipping match entry {i} due to missing \'url_404\'.")
            continue # Skip if the 404 URL is missing

        print(f"\nReviewing Match {i+1}/{len(matches_to_review)}")
        print(f"404 URL: {url_404}")

        # Get the top 5 suggestions from the algorithms
        top_algo_suggestions = _get_top_suggestions(match_info, top_n=5)
        # Generate the parent URL as the 6th option
        parent_url_suggestion = _get_parent_url(url_404)

        options = top_algo_suggestions # Start with algorithm suggestions
        # Add parent URL only if it exists, is unique among suggestions, and is present in the live URLs
        if parent_url_suggestion and \
           parent_url_suggestion not in options and \
           parent_url_suggestion in live_url_set:
            options.append(parent_url_suggestion) # Add parent URL if unique and valid

        if not options:
            print("No potential redirect suggestions found (including valid parent URL). Skipping.")
            continue # Skip if no options could be generated

        print("\nPotential Redirects:")
        # Display the numbered options to the user
        for idx, opt_url in enumerate(options):
            print(f"{idx + 1}: {opt_url}")

        # Prompt the user for their choice
        while True:
            # Add 'manual' to the prompt options
            user_input = input(f"Enter the number (1-{len(options)}) of the correct redirect, type 'm' to enter a URL, or type 'skip' or 'quit': ").lower()

            if user_input == 'quit':
                print("Ending active learning session.")
                return verified_pairs # Return collected pairs so far
            elif user_input == 'skip':
                print("Skipping this URL.")
                break # Move to the next 404 URL
            elif user_input == 'm':
                manual_url = input("Enter the correct live URL: ").strip()
                if not manual_url:
                    print("No URL entered. Please try again or choose another option.")
                    continue # Ask for input again
                # Validate if the manually entered URL exists in the live URLs list
                if manual_url in live_url_set:
                    print(f"Selected (m): {manual_url}")
                    verified_pairs.append((url_404, manual_url))
                    break # Move to the next 404 URL
                else:
                    print("Error: The entered URL was not found in the list of known live URLs. Please ensure it is correct and exists on the site.")
                    # Stay in the loop to allow user to try again or choose another option
            elif user_input.isdigit():
                try:
                    choice_idx = int(user_input) - 1 # Convert to 0-based index
                    # Validate the user's choice
                    if 0 <= choice_idx < len(options):
                        selected_live_url = options[choice_idx]
                        print(f"Selected: {selected_live_url}")
                        # Add the verified pair (404 URL, selected Live URL) to the list
                        verified_pairs.append((url_404, selected_live_url))
                        break # Move to the next 404 URL
                    else:
                        print(f"Invalid number. Please enter a number between 1 and {len(options)}, 'm', 'skip', or 'quit'.")
                except ValueError:
                    # This case should ideally not be reached if isdigit() is true, but handle defensively
                    print("Invalid input. Please enter a number, 'm', 'skip', or 'quit'.")
            else:
                print("Invalid input. Please enter a number, 'm', 'skip', or 'quit'.")

    print("\n--- Active Learning Session Finished ---")
    # Return all pairs verified by the user during the session
    return verified_pairs

# Example usage structure (for testing, would be called from main.py)
if __name__ == '__main__':
    # Create dummy data similar to what would be passed from main.py
    dummy_matches = [
        {
            'url_404': 'https://www.example.com/products/old-widget',
            'Algo1': {'match': 'https://www.example.com/products/new-widget', 'score': 0.9},
            'Algo2': {'match': 'https://www.example.com/products/new-widget', 'score': 0.8},
            'Algo3': {'match': 'https://www.example.com/products', 'score': 0.7},
            'ML': {'match': 'https://www.example.com/products/new-widget', 'score': 0.95}
        },
        {
            'url_404': 'https://www.example.com/about/team/john-doe',
            'Algo1': {'match': 'https://www.example.com/about/team', 'score': 0.8},
            'Algo2': {'match': 'https://www.example.com/about-us/staff', 'score': 0.7},
        },
        {
            'url_404': 'https://www.example.com/promo/expired',
            'Algo1': {'match': 'https://www.example.com/', 'score': 0.6},
        }
    ]
    # Correct the column name in the dummy DataFrame to 'URL' (uppercase)
    dummy_df_404 = pd.DataFrame({'URL': ['https://www.example.com/products/old-widget', 'https://www.example.com/about/team/john-doe', 'https://www.example.com/promo/expired']})
    dummy_df_live = pd.DataFrame({'URL': ['https://www.example.com/products/new-widget', 'https://www.example.com/products', 'https://www.example.com/about/team', 'https://www.example.com/about-us/staff', 'https://www.example.com/']})

    # Configure basic logging for the example
    logging.basicConfig(level=logging.INFO)

    # Run the active learning session with dummy data
    user_verified = start_active_learning_session(dummy_matches, dummy_df_404, dummy_df_live)

    # Print the results
    if user_verified:
        print("\nUser Verified Pairs:")
        for url_404, url_live in user_verified:
            print(f"  404: {url_404} -> Verified Live: {url_live}")
    else:
        print("\nNo pairs were verified by the user.") 